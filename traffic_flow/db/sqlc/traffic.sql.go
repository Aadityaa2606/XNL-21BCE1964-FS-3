// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: traffic.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDailyTrafficStats = `-- name: GetDailyTrafficStats :many
SELECT
  DATE_TRUNC('day', timestamp) as day,
  sensor_id,
  AVG(traffic_volume) as avg_volume,
  MAX(traffic_volume) as max_volume,
  MIN(traffic_volume) as min_volume,
  AVG(average_speed) as avg_speed
FROM traffic_data
WHERE timestamp BETWEEN $1 AND $2
GROUP BY day, sensor_id
ORDER BY day, sensor_id
`

type GetDailyTrafficStatsParams struct {
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Timestamp_2 pgtype.Timestamp `json:"timestamp_2"`
}

type GetDailyTrafficStatsRow struct {
	Day       pgtype.Interval `json:"day"`
	SensorID  int32           `json:"sensor_id"`
	AvgVolume float64         `json:"avg_volume"`
	MaxVolume interface{}     `json:"max_volume"`
	MinVolume interface{}     `json:"min_volume"`
	AvgSpeed  float64         `json:"avg_speed"`
}

func (q *Queries) GetDailyTrafficStats(ctx context.Context, arg GetDailyTrafficStatsParams) ([]GetDailyTrafficStatsRow, error) {
	rows, err := q.db.Query(ctx, getDailyTrafficStats, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDailyTrafficStatsRow{}
	for rows.Next() {
		var i GetDailyTrafficStatsRow
		if err := rows.Scan(
			&i.Day,
			&i.SensorID,
			&i.AvgVolume,
			&i.MaxVolume,
			&i.MinVolume,
			&i.AvgSpeed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighCongestionAreas = `-- name: GetHighCongestionAreas :many
SELECT 
  td.sensor_id,
  s.latitude,
  s.longitude,
  COUNT(*) as high_congestion_count
FROM traffic_data td
JOIN sensors s ON td.sensor_id = s.sensor_id
WHERE td.congestion_level = 'high'
AND td.timestamp BETWEEN $1 AND $2
GROUP BY td.sensor_id, s.latitude, s.longitude
ORDER BY high_congestion_count DESC
LIMIT $3
`

type GetHighCongestionAreasParams struct {
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Timestamp_2 pgtype.Timestamp `json:"timestamp_2"`
	Limit       int32            `json:"limit"`
}

type GetHighCongestionAreasRow struct {
	SensorID            int32   `json:"sensor_id"`
	Latitude            float64 `json:"latitude"`
	Longitude           float64 `json:"longitude"`
	HighCongestionCount int64   `json:"high_congestion_count"`
}

func (q *Queries) GetHighCongestionAreas(ctx context.Context, arg GetHighCongestionAreasParams) ([]GetHighCongestionAreasRow, error) {
	rows, err := q.db.Query(ctx, getHighCongestionAreas, arg.Timestamp, arg.Timestamp_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHighCongestionAreasRow{}
	for rows.Next() {
		var i GetHighCongestionAreasRow
		if err := rows.Scan(
			&i.SensorID,
			&i.Latitude,
			&i.Longitude,
			&i.HighCongestionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestTrafficData = `-- name: GetLatestTrafficData :many
SELECT 
  td.sensor_id, td.timestamp, td.traffic_volume, td.average_speed, td.congestion_level,
  s.latitude,
  s.longitude
FROM traffic_data td
JOIN sensors s ON td.sensor_id = s.sensor_id
WHERE td.timestamp >= NOW() - INTERVAL '1 hour'
ORDER BY td.timestamp DESC
LIMIT $1
`

type GetLatestTrafficDataRow struct {
	SensorID        int32               `json:"sensor_id"`
	Timestamp       pgtype.Timestamp    `json:"timestamp"`
	TrafficVolume   int32               `json:"traffic_volume"`
	AverageSpeed    float64             `json:"average_speed"`
	CongestionLevel CongestionLevelType `json:"congestion_level"`
	Latitude        float64             `json:"latitude"`
	Longitude       float64             `json:"longitude"`
}

func (q *Queries) GetLatestTrafficData(ctx context.Context, limit int32) ([]GetLatestTrafficDataRow, error) {
	rows, err := q.db.Query(ctx, getLatestTrafficData, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestTrafficDataRow{}
	for rows.Next() {
		var i GetLatestTrafficDataRow
		if err := rows.Scan(
			&i.SensorID,
			&i.Timestamp,
			&i.TrafficVolume,
			&i.AverageSpeed,
			&i.CongestionLevel,
			&i.Latitude,
			&i.Longitude,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSensorCongestionDistribution = `-- name: GetSensorCongestionDistribution :many
SELECT
  sensor_id,
  congestion_level,
  COUNT(*) as count
FROM traffic_data
WHERE timestamp BETWEEN $1 AND $2
GROUP BY sensor_id, congestion_level
ORDER BY sensor_id, congestion_level
`

type GetSensorCongestionDistributionParams struct {
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Timestamp_2 pgtype.Timestamp `json:"timestamp_2"`
}

type GetSensorCongestionDistributionRow struct {
	SensorID        int32               `json:"sensor_id"`
	CongestionLevel CongestionLevelType `json:"congestion_level"`
	Count           int64               `json:"count"`
}

func (q *Queries) GetSensorCongestionDistribution(ctx context.Context, arg GetSensorCongestionDistributionParams) ([]GetSensorCongestionDistributionRow, error) {
	rows, err := q.db.Query(ctx, getSensorCongestionDistribution, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSensorCongestionDistributionRow{}
	for rows.Next() {
		var i GetSensorCongestionDistributionRow
		if err := rows.Scan(&i.SensorID, &i.CongestionLevel, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrafficAverages = `-- name: GetTrafficAverages :one
SELECT 
  AVG(traffic_volume) as avg_volume,
  AVG(average_speed) as avg_speed,
  sensor_id
FROM traffic_data
WHERE sensor_id = $1
AND timestamp BETWEEN $2 AND $3
GROUP BY sensor_id
`

type GetTrafficAveragesParams struct {
	SensorID    int32            `json:"sensor_id"`
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Timestamp_2 pgtype.Timestamp `json:"timestamp_2"`
}

type GetTrafficAveragesRow struct {
	AvgVolume float64 `json:"avg_volume"`
	AvgSpeed  float64 `json:"avg_speed"`
	SensorID  int32   `json:"sensor_id"`
}

func (q *Queries) GetTrafficAverages(ctx context.Context, arg GetTrafficAveragesParams) (GetTrafficAveragesRow, error) {
	row := q.db.QueryRow(ctx, getTrafficAverages, arg.SensorID, arg.Timestamp, arg.Timestamp_2)
	var i GetTrafficAveragesRow
	err := row.Scan(&i.AvgVolume, &i.AvgSpeed, &i.SensorID)
	return i, err
}

const getTrafficDataBySensor = `-- name: GetTrafficDataBySensor :many
SELECT sensor_id, timestamp, traffic_volume, average_speed, congestion_level FROM traffic_data
WHERE sensor_id = $1
AND timestamp BETWEEN $2 AND $3
ORDER BY timestamp DESC
`

type GetTrafficDataBySensorParams struct {
	SensorID    int32            `json:"sensor_id"`
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Timestamp_2 pgtype.Timestamp `json:"timestamp_2"`
}

func (q *Queries) GetTrafficDataBySensor(ctx context.Context, arg GetTrafficDataBySensorParams) ([]TrafficDatum, error) {
	rows, err := q.db.Query(ctx, getTrafficDataBySensor, arg.SensorID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrafficDatum{}
	for rows.Next() {
		var i TrafficDatum
		if err := rows.Scan(
			&i.SensorID,
			&i.Timestamp,
			&i.TrafficVolume,
			&i.AverageSpeed,
			&i.CongestionLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordTrafficData = `-- name: RecordTrafficData :one
INSERT INTO traffic_data (
  sensor_id,
  timestamp,
  traffic_volume,
  average_speed,
  congestion_level
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING sensor_id, timestamp, traffic_volume, average_speed, congestion_level
`

type RecordTrafficDataParams struct {
	SensorID        int32               `json:"sensor_id"`
	Timestamp       pgtype.Timestamp    `json:"timestamp"`
	TrafficVolume   int32               `json:"traffic_volume"`
	AverageSpeed    float64             `json:"average_speed"`
	CongestionLevel CongestionLevelType `json:"congestion_level"`
}

func (q *Queries) RecordTrafficData(ctx context.Context, arg RecordTrafficDataParams) (TrafficDatum, error) {
	row := q.db.QueryRow(ctx, recordTrafficData,
		arg.SensorID,
		arg.Timestamp,
		arg.TrafficVolume,
		arg.AverageSpeed,
		arg.CongestionLevel,
	)
	var i TrafficDatum
	err := row.Scan(
		&i.SensorID,
		&i.Timestamp,
		&i.TrafficVolume,
		&i.AverageSpeed,
		&i.CongestionLevel,
	)
	return i, err
}
