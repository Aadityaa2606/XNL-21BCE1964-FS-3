// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sensor.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSensor = `-- name: CreateSensor :one
INSERT INTO sensors (
  latitude,
  longitude,
  type_id,
  installation_date,
  status
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING sensor_id, latitude, longitude, type_id, installation_date, status
`

type CreateSensorParams struct {
	Latitude         float64     `json:"latitude"`
	Longitude        float64     `json:"longitude"`
	TypeID           int32       `json:"type_id"`
	InstallationDate pgtype.Date `json:"installation_date"`
	Status           string      `json:"status"`
}

func (q *Queries) CreateSensor(ctx context.Context, arg CreateSensorParams) (Sensor, error) {
	row := q.db.QueryRow(ctx, createSensor,
		arg.Latitude,
		arg.Longitude,
		arg.TypeID,
		arg.InstallationDate,
		arg.Status,
	)
	var i Sensor
	err := row.Scan(
		&i.SensorID,
		&i.Latitude,
		&i.Longitude,
		&i.TypeID,
		&i.InstallationDate,
		&i.Status,
	)
	return i, err
}

const createSensorType = `-- name: CreateSensorType :one
INSERT INTO sensor_types (
  type_name,
  description
) VALUES (
  $1, $2
) RETURNING type_id, type_name, description
`

type CreateSensorTypeParams struct {
	TypeName    string      `json:"type_name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) CreateSensorType(ctx context.Context, arg CreateSensorTypeParams) (SensorType, error) {
	row := q.db.QueryRow(ctx, createSensorType, arg.TypeName, arg.Description)
	var i SensorType
	err := row.Scan(&i.TypeID, &i.TypeName, &i.Description)
	return i, err
}

const deleteSensor = `-- name: DeleteSensor :exec
DELETE FROM sensors
WHERE sensor_id = $1
`

func (q *Queries) DeleteSensor(ctx context.Context, sensorID int32) error {
	_, err := q.db.Exec(ctx, deleteSensor, sensorID)
	return err
}

const deleteSensorType = `-- name: DeleteSensorType :exec
DELETE FROM sensor_types
WHERE type_id = $1
`

func (q *Queries) DeleteSensorType(ctx context.Context, typeID int32) error {
	_, err := q.db.Exec(ctx, deleteSensorType, typeID)
	return err
}

const getActiveSensors = `-- name: GetActiveSensors :many
SELECT 
  s.sensor_id,
  s.latitude,
  s.longitude,
  s.installation_date,
  s.status,
  st.type_name
FROM sensors s
JOIN sensor_types st ON s.type_id = st.type_id
WHERE s.status = 'active'
ORDER BY s.sensor_id
`

type GetActiveSensorsRow struct {
	SensorID         int32       `json:"sensor_id"`
	Latitude         float64     `json:"latitude"`
	Longitude        float64     `json:"longitude"`
	InstallationDate pgtype.Date `json:"installation_date"`
	Status           string      `json:"status"`
	TypeName         string      `json:"type_name"`
}

func (q *Queries) GetActiveSensors(ctx context.Context) ([]GetActiveSensorsRow, error) {
	rows, err := q.db.Query(ctx, getActiveSensors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveSensorsRow{}
	for rows.Next() {
		var i GetActiveSensorsRow
		if err := rows.Scan(
			&i.SensorID,
			&i.Latitude,
			&i.Longitude,
			&i.InstallationDate,
			&i.Status,
			&i.TypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSensor = `-- name: GetSensor :one
SELECT 
  s.sensor_id,
  s.latitude,
  s.longitude,
  s.installation_date,
  s.status,
  st.type_name,
  st.description as type_description
FROM sensors s
JOIN sensor_types st ON s.type_id = st.type_id
WHERE s.sensor_id = $1
`

type GetSensorRow struct {
	SensorID         int32       `json:"sensor_id"`
	Latitude         float64     `json:"latitude"`
	Longitude        float64     `json:"longitude"`
	InstallationDate pgtype.Date `json:"installation_date"`
	Status           string      `json:"status"`
	TypeName         string      `json:"type_name"`
	TypeDescription  pgtype.Text `json:"type_description"`
}

func (q *Queries) GetSensor(ctx context.Context, sensorID int32) (GetSensorRow, error) {
	row := q.db.QueryRow(ctx, getSensor, sensorID)
	var i GetSensorRow
	err := row.Scan(
		&i.SensorID,
		&i.Latitude,
		&i.Longitude,
		&i.InstallationDate,
		&i.Status,
		&i.TypeName,
		&i.TypeDescription,
	)
	return i, err
}

const getSensorType = `-- name: GetSensorType :one
SELECT type_id, type_name, description FROM sensor_types
WHERE type_id = $1
`

func (q *Queries) GetSensorType(ctx context.Context, typeID int32) (SensorType, error) {
	row := q.db.QueryRow(ctx, getSensorType, typeID)
	var i SensorType
	err := row.Scan(&i.TypeID, &i.TypeName, &i.Description)
	return i, err
}

const getSensorsByType = `-- name: GetSensorsByType :many
SELECT 
  sensor_id,
  latitude,
  longitude,
  installation_date,
  status
FROM sensors
WHERE type_id = $1
ORDER BY sensor_id
`

type GetSensorsByTypeRow struct {
	SensorID         int32       `json:"sensor_id"`
	Latitude         float64     `json:"latitude"`
	Longitude        float64     `json:"longitude"`
	InstallationDate pgtype.Date `json:"installation_date"`
	Status           string      `json:"status"`
}

func (q *Queries) GetSensorsByType(ctx context.Context, typeID int32) ([]GetSensorsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getSensorsByType, typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSensorsByTypeRow{}
	for rows.Next() {
		var i GetSensorsByTypeRow
		if err := rows.Scan(
			&i.SensorID,
			&i.Latitude,
			&i.Longitude,
			&i.InstallationDate,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSensorTypes = `-- name: ListSensorTypes :many
SELECT type_id, type_name, description FROM sensor_types
ORDER BY type_name
`

func (q *Queries) ListSensorTypes(ctx context.Context) ([]SensorType, error) {
	rows, err := q.db.Query(ctx, listSensorTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SensorType{}
	for rows.Next() {
		var i SensorType
		if err := rows.Scan(&i.TypeID, &i.TypeName, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSensors = `-- name: ListSensors :many
SELECT 
  s.sensor_id,
  s.latitude,
  s.longitude,
  s.installation_date,
  s.status,
  st.type_name,
  st.description as type_description
FROM sensors s
JOIN sensor_types st ON s.type_id = st.type_id
ORDER BY s.sensor_id
`

type ListSensorsRow struct {
	SensorID         int32       `json:"sensor_id"`
	Latitude         float64     `json:"latitude"`
	Longitude        float64     `json:"longitude"`
	InstallationDate pgtype.Date `json:"installation_date"`
	Status           string      `json:"status"`
	TypeName         string      `json:"type_name"`
	TypeDescription  pgtype.Text `json:"type_description"`
}

func (q *Queries) ListSensors(ctx context.Context) ([]ListSensorsRow, error) {
	rows, err := q.db.Query(ctx, listSensors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSensorsRow{}
	for rows.Next() {
		var i ListSensorsRow
		if err := rows.Scan(
			&i.SensorID,
			&i.Latitude,
			&i.Longitude,
			&i.InstallationDate,
			&i.Status,
			&i.TypeName,
			&i.TypeDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSensorStatus = `-- name: UpdateSensorStatus :one
UPDATE sensors
SET status = $2
WHERE sensor_id = $1
RETURNING sensor_id, latitude, longitude, type_id, installation_date, status
`

type UpdateSensorStatusParams struct {
	SensorID int32  `json:"sensor_id"`
	Status   string `json:"status"`
}

func (q *Queries) UpdateSensorStatus(ctx context.Context, arg UpdateSensorStatusParams) (Sensor, error) {
	row := q.db.QueryRow(ctx, updateSensorStatus, arg.SensorID, arg.Status)
	var i Sensor
	err := row.Scan(
		&i.SensorID,
		&i.Latitude,
		&i.Longitude,
		&i.TypeID,
		&i.InstallationDate,
		&i.Status,
	)
	return i, err
}

const updateSensorType = `-- name: UpdateSensorType :one
UPDATE sensor_types
SET type_name = $2,
    description = $3
WHERE type_id = $1
RETURNING type_id, type_name, description
`

type UpdateSensorTypeParams struct {
	TypeID      int32       `json:"type_id"`
	TypeName    string      `json:"type_name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) UpdateSensorType(ctx context.Context, arg UpdateSensorTypeParams) (SensorType, error) {
	row := q.db.QueryRow(ctx, updateSensorType, arg.TypeID, arg.TypeName, arg.Description)
	var i SensorType
	err := row.Scan(&i.TypeID, &i.TypeName, &i.Description)
	return i, err
}
